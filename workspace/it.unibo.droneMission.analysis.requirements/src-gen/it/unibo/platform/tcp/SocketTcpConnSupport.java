/*
*  Generated by AN Unibo
*/
package it.unibo.platform.tcp;
 
import it.unibo.is.interfaces.IOutputView;
import it.unibo.is.interfaces.protocols.ITcpInteraction;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.Socket;
import java.net.SocketException;


public class SocketTcpConnSupport implements ITcpInteraction{
private boolean debug = false;
private String logo;
private Socket socket;
private DataOutputStream outputChannel;
private BufferedReader inputChannel;
private IOutputView view;
protected boolean isRaw = false;
protected OutputStream outStream 	;
protected InputStream inStream  	;
protected boolean endOfRaw = false;

	public SocketTcpConnSupport(String logo, Socket socket,IOutputView view) {
		this.logo 	= logo;
		this.socket = socket;
		this.view   = view ;
		try {
			outStream 		= socket.getOutputStream();
			inStream  		= socket.getInputStream();
			outputChannel 	= new DataOutputStream(outStream);
			inputChannel    = new BufferedReader( new InputStreamReader( inStream ) );	
			if( System.getProperty("tcpLowTrace") != null ) 
				debug = System.getProperty("tcpLowTrace").equals("set") ;
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public String getlogo(){
		return logo;
	}

	
	public Socket getSocket(){
		return socket;
	}
	
	public void closeConnection() throws Exception{
		println(" CLOSING ");
		socket.close();
	}

	/**
	 * Implementation based on DataOutputStream
	 * @param outputChannel
	 * @param msg 
	 * @throws Exception
	 */
	public synchronized void sendALine( String msg ) throws Exception{
		println( "sendALine ... " + msg + " localPort=" + socket.getLocalPort() + " port=" + socket.getPort());
		outputChannel.writeBytes( msg+"\n" );	
		println( "has written ... " +msg    );
		outputChannel.flush();
		//Thread.sleep(100); //get the time to flush
	}
	
 	public void sendALine(String msg, boolean isAnswer) throws Exception {
		sendALine(msg);
	}
	
 	public synchronized void resumeSender(){
 		endOfRaw = true;
 		notifyAll();
 	}

	@Override
	public synchronized void sendRaw(byte[] msg) throws Exception {
		if( msg == null ){
			//nothing more to send
  			while( ! endOfRaw ) wait();
			endOfRaw = false;
 			//System.out.println("SocketTcpConnSupport sender raw RESUMES "  );
 			return;
		}
		//System.out.println("SocketTcpConnSupport sendALine byte " + (msg.length));
 		outputChannel.write( msg );
		outputChannel.flush();
	}
	
	public synchronized void sendACmdLine( String msg ) throws Exception{
		outputChannel.write( (msg+"\n").getBytes());
		outputChannel.flush();
		//Thread.sleep(100); //get the time to flush
	}
	
	public  String receiveALine(  ) throws Exception{
			return receiveALine(0);		
	}
	
	public  String receiveALine( int timeOut ) throws Exception{
 		println( "receiveALine trying ... " + Thread.currentThread().getName()  + " timeOut="+timeOut);
 		try {
			if( isRaw ) return  null;	//The control is taken by the HIGH LEVEL
			socket.setSoTimeout(timeOut);
			String	line = inputChannel.readLine();  //blocking =>
			println( "has read ... " +line  );
			if( line.contains("startCommRaw") ){
				System.out.println( " **** COMMUTE TO RAW FOR " +line + " conn="  + this );
				isRaw = true;
			}
			return line;		
		} catch (SocketException e) {
	 		println( "timeOut" +  socket.getLocalPort());
			throw e;
		}
	}
 	public int receiveRaw( byte[] buffer ) throws Exception{
		return receiveRaw( buffer, 0 );
	}
	public  int receiveRaw( byte[] buffer, int timeOut ) throws Exception{
  		println( "receiveRaw trying ... " + Thread.currentThread().getName()  + " timeOut="+timeOut);
 		try {
   			socket.setSoTimeout(timeOut);
   			int nn = inStream.read(buffer);
   			//When the buffer is partially full it means that the source is terminated
   			//WARNING : what happens if the source length is buffer.length*N (int N>0)?
   			if( nn > 0  && nn < buffer.length   ) { 
   				isRaw = false;
   				System.out.println( " **** COMMUTE BACK TO STRING " + " conn="  + this );
  				sendRaw( (it.unibo.contact.platformuv.RunTimeKb.endOfRawStr+"\n").getBytes());
				it.unibo.contact.platformuv.ConnInputReceiver.resumeNormalMode();
 			}
   			//System.out.println( "receiveRaw return ... " + nn);
  			return nn;
 		} catch (SocketException e) {
	 		println( "timeOut" +  socket.getLocalPort());
			return -1;
		}
	}
	
	/**
	 * A smart implementation of receiveALine based on BufferedReader
	 * @param inputChannel
	 * @return
	 * @throws Exception
	 */

	public  String receiveACmdLine( InputStream inChannel ) throws Exception{
		byte[] 	b = new byte[100];
		int msgLength = 0;
			int n = inChannel.read(b,0,b.length);  //like a receive
			msgLength += n;
//			println( "has read " + n + " bytes\n" + (char)b[n-1]  );
			while( b[msgLength-1] != (byte)'\n' ){
				n = inChannel.read(b,msgLength,100-msgLength);
				msgLength += n;
//				println( "has read " + n + " bytes\n"  + (char)b[msgLength-1]  );
			}
			String cmd = new String(b,0,msgLength-1);
			println( "has received ... " +cmd  );
			return cmd;			
	}
	
	
	protected  void println( String msg){
		 if( debug ) 
			 doprintln("		+++ SocketTcpConnSupport|" + logo + " " + msg  );
	}

	protected  void doprintln( String msg){
		if( view != null )
			view.addOutput(msg);
		else System.out.println(msg  );		
	}
	
}
	
