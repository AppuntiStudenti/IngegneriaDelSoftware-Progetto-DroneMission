/*
*  Generated by AN Unibo
*/
package it.unibo.contact.platformuv;
import it.unibo.is.interfaces.*;
import it.unibo.is.interfaces.platforms.ILindaLike;
import it.unibo.is.interfaces.protocols.*;
import it.unibo.is.interfaces.services.*;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Vector;
import alice.tuprolog.Struct;
import alice.tuprolog.Term;

public class ConnProtOut implements ILindaLike {
	private static HashMap<String, IConnInteraction> outConn = new HashMap<String, IConnInteraction>();

	protected String receiver;
	protected String msgId;
	protected String sender;
	protected IConnInteraction connection;
	protected IServiceTcp tcpServ;
	protected boolean debug = false;
	protected IOutputView view;
	protected String hostname;
	protected int portNum;
	protected boolean timeToEnd = false;
	protected ReceiveThread rt = null;
	
	public ConnProtOut(String receiver, String msgId, String sender,
			IOutputView view) throws Exception {
		this.receiver = receiver;
		this.msgId = msgId;
		this.sender = sender;
		this.view = view;
		hostname = RunTimeKb.getHostName(receiver, msgId);
		portNum = RunTimeKb.getPortNum(receiver, msgId);
		if (System.getProperty("ConnProtOut") != null)
			debug = System.getProperty("ConnProtOut").equals("set");
		println("ConnProtOut CREATED FOR " + " receiver=" + receiver   + "msgId="+msgId);		
	}

	/*
	 * This constructor is used by ConnReceiver.handleConnectionMsg
	 */
	public ConnProtOut(String receiver, String msgId, String sender,
			IConnInteraction connection, IOutputView view) throws Exception {
		this(receiver, msgId, sender, view);
		this.connection = connection;
		outConn.put("" + portNum, connection);
		println(
"ConnProtOut WITH CONN CREATED FOR " + " receiver=" + receiver + " sender="+sender + "msgId="+msgId);
		//ADDED TO HANDLE RAW MESSAGES
		rt = new ReceiveThread(sender,connection,view);
		rt.start();
	}

	public synchronized void out(final String msg) throws Exception {
		println("sending " + msg + " conn= " + connection);
		if (connection == null) {
			// Start a thread to establish a connection
			ConnectThread cth = new ConnectThread(this, msg, view);
			cth.start();
			while (connection == null && !timeToEnd) {
				println("waiting for a connection to " + receiver);
				wait();
				println("resuming " + receiver + "  timeToEnd=" + timeToEnd);
			}
			if (timeToEnd) {
				timeToEnd = false;
				terminate();
				throw new Exception("connection exception");
			}
			if (connection != null)
				connection.sendALine(msg);
		} else
			connection.sendALine(msg);
	}

	
	public void acquireControl() throws Exception{
		rt.setRawMsg();
	}
	public void releaseControl() throws Exception{
		rt.resetRawMsg();
	}	
 	public RawBuffer receiveRaw( ) throws Exception{ 	
 		if( rt == null ){
			//ADDED TO HANDLE RAW MESSAGES TODO
			rt = new ReceiveThread(sender,connection,view);
			rt.start(); 			
 		}
 		return rt.receiveRaw( );
 	}
 	public boolean receiveRawCompleted( ) throws Exception{ 	
 		return rt.receiveRawCompleted( );
 	} 	
	public synchronized IMessage in(String query) throws Exception {
		System.out.println(" ****  NEVER HERE ConnProtOut ****** "
				+ query);
		throw new Exception("	%%% ConnProtOut does not support rd");
	}

	public IMessage rd(int LastMsgNum, String queryMsg) throws Exception {
		throw new Exception("	%%% ConnProtOut does not support rd");
	}
	@Override
	public IMessage rdMostRecent(int LastMsgNum, String queryMsg)
			throws Exception {
		throw new Exception("	%%% ConnProtOut does not support rdMostRecent");
	}

	@Override
	public IMessage rdwMostRecent(int LastMsgNum, String queryMsg)
			throws Exception {
		throw new Exception("	%%% ConnProtOut does not support rdwMostRecent");
	}
	 

	public boolean check(String queryS) throws Exception {
		throw new Exception("	%%% ConnProtOut does not support check");
	}

	public Vector<IMessage> inMany(Vector<String> tokens) throws Exception {
		throw new Exception("	%%% ConnProtOut does not support inMany");
	}

	public IMessage select(String subjName,Hashtable<String, Integer> lastMsgRdMemo,
			java.util.List<IMessage> queries) throws Exception {
		throw new Exception(
				"	%%% ConnProtOut does not support inOneFromMany");
	}
	public IMessage selectMostRecent( 
		String subjName, Hashtable<String,Integer> lastMsgRdMemo, java.util.List<IMessage> queries ) throws Exception {
		throw new Exception("	%%% ConnProtOut does not support selectMostRecent");
	}

	public IMessage rdw(int LastMsgNum, String queryMsg) throws Exception {
		throw new Exception("	%%% ConnProtOut does not support rdw");
	}

	// _-------------------------------------------------------

	public IConnInteraction connect() throws Exception {
		IConnInteraction conn = connection;
		conn = outConn.get("" + portNum);
		println(" --- FOUND connection for " + portNum + " = " + conn);
		if (conn == null) {
			conn = doConnect();
			println(" connection after doConnect for " + portNum + " = " + conn);
			if (conn != null && ! RunTimeKb.worksWith( "HTTP", receiver, msgId) ){
				outConn.put("" + portNum, conn);
				rt = new ReceiveThread(receiver,conn,view);
				rt.start();
//				new ConnInputReceiver(this,""+portNum,conn,view).start();
			}
		}
		connection = conn;
		return connection;
	}

	// To be redefined
	public IConnInteraction doConnect() throws Exception {
		System.out.println("ConnProtOut doConnect=" + connection);
		return connection;
	}

	public synchronized void setConnection(IConnInteraction conn) {
		connection = conn;
		notifyAll();
	}

	public synchronized IConnInteraction getConnection() {
		return connection;
	}

	public synchronized void setTimeToEnd() {
		this.timeToEnd = true;
		notifyAll();
	}

	// _-------------------------------------------------------
	public void terminate() throws Exception {
		if (connection != null) {
			println("close out connection");
			connection.closeConnection();
		} else
			println("terminates without any connection");
	}

	protected void println(String msg) {
		String m = "    %%% ConnProtOut " + msg;
		if (debug)
			if (view != null)
				view.addOutput(m);
			else
				System.out.println(m);
	}
}

/*
 * ------------------------------------------- 
 * ConnectThread
 * -------------------------------------------
 */

class ConnectThread extends Thread {
	private IConnInteraction conn = null;
	private ConnProtOut outSupport;
	private String msg;
	private boolean running = false;
	private IOutputView view;
	private boolean debug = false;

	public ConnectThread(ConnProtOut outSupport, String msg, IOutputView view) {
		this.outSupport = outSupport;
		this.msg = msg;
		this.view = view;
		setName("ConnectThread_" + msg);
	}

	public void run() {
		println("started for ... " + msg);
		running = true;
		connect();
	}

	protected void connect() {
		int numOfTest = 15;
		if (System.getProperty("numOfConnectionAttempts") != null)
			numOfTest = Integer.parseInt(System
					.getProperty("numOfConnectionAttempts"));
		for (int i = 0; i < numOfTest; i++) {
			try {
				// println("connection attempt n=" + i );
				conn = outSupport.connect(); // bloccante
				outSupport.setConnection(conn);
				break;
			} catch (Exception e) {
				println(e.getMessage() + " attempt n=" + i);
			}
		}// for
		try {
			println("connect ends its attempts " + (conn != null));
			running = false;
			if (conn == null)
				outSupport.setTimeToEnd();
		} catch (Exception e) {
			//e.printStackTrace();
			println("connect ERROR " + e.getMessage() );
		}
	}

	protected void println(String msg) {
		String m = "    %%% ConnectThread  " + msg;
		if (debug)
			if (view != null)
				view.addOutput(m);
			else
				System.out.println(m);
	}
}

/*
 * ---------------------------------------------------------
 * ReceiveThread
 * ---------------------------------------------------------
*/
class ReceiveThread extends ConnInputReceiver {
 	protected boolean rowMsg = false;
 	protected int rowLength = 0;
 	protected int rowMsgLength = 0;
	protected String msgAvailable = null;
	protected String msgRawAvailable = null;
	protected RawBuffer rowBufferAvailable = null;
	protected boolean requestOn = false;
	protected boolean goon = true;
	protected String receiver ;
	protected boolean receiveRawCompleted = false;
	protected IOutputView view;
	
	public ReceiveThread(String receiver,IConnInteraction connection,IOutputView view) throws Exception{
		super("RecThreadConnFrom_"+receiver,connection,null);
		this.receiver = receiver;
		this.view = view;
		println("CREATED");
 	}		
	public void setRawMsg() throws Exception{
		//System.out.println("*** setRawMsg");
		receiveRawCompleted = false;
		rowMsg = true;
	}
	public void resetRawMsg() throws Exception{
		println("resetRawMsg");
		rowMsg = false;
	}
 	public boolean receiveRawCompleted( ) throws Exception{ 	
 		return receiveRawCompleted;
 	} 		
	public synchronized RawBuffer receiveRaw( ) throws Exception{
		println("receiveRaw rowBufferAvailable=" + rowBufferAvailable );
		requestOn = true;
		notifyAll();
		while( rowBufferAvailable == null ) wait();
		RawBuffer m = rowBufferAvailable;
		//System.out.println("receiveRaw " + m.dim );
		rowBufferAvailable = null;
		if(m.dim==0) resetRawMsg();
		return m;
	}	
	public synchronized void receiveTheAnswwer() throws Exception{
		try{
		//System.out.println("*** receiveTheAnswwer rowMsg="+ rowMsg + " requestOn=" + requestOn);
   		if( rowMsg ){
 	 		while(! requestOn ) wait();	 		
   			if( rowLength >= rowMsgLength ){
   				rowBufferAvailable = new RawBuffer(); //empty buffer
   				notifyAll();
   				return;
  			}
  	 		byte[] buffer = new byte[8000];
 	 		int n = conn.receiveRaw(buffer) ;
 	 		if( n < 0 ){
 				System.out.println("*** receiveTheAnswer n="+n);
	  			return;
 	 		}	
  	 		//System.out.println("***receiveTheAnswwer received on buffer "+ n);
  			rowBufferAvailable = new RawBuffer(buffer,n);
  			rowLength = rowLength + n;
			//System.out.println( "***receiveTheAnswer received " + n + "/"+rowLength + "/"+ rowMsgLength);
			requestOn = false;
			notifyAll();
		}else{
			msgAvailable = conn.receiveALine();//new String(buffer, "WINDOWS-1252") ;
 			//System.out.println("***receiveTheAnswwer received LINE "+msgAvailable + " rowMsg=" + rowMsg);
  			if( msgAvailable == null ){
  				goon = false;
  				return;
  			}
  			if( msgAvailable.equals(RunTimeKb.endOfRawStr) ){
 	 			System.out.println("***receiveTheAnswwer received "+ RunTimeKb.endOfRawStr+ " conn=" + conn);
 	 			if( conn instanceof it.unibo.platform.tcp.SocketTcpConnSupport ){
 	 				((it.unibo.platform.tcp.SocketTcpConnSupport)conn).resumeSender( ); //TODO since ADHOC by AN
 	 				return;
 	 			}
  			}
  			else checkAndStoreAnswer(msgAvailable)  ;
			requestOn = false;
			notifyAll();
		}		
		}catch(Exception e){
			System.out.println("$$$ ReceiveThread terminates: " + e.getMessage());
			throw(e);
		}
	}
		
	public void run(){
		String m;
		try {
			while(goon){
				receiveTheAnswwer() ;
   			}
			println("ENDS"  );
			if (conn == null) {
				//IS A SIMPLE OUT
				return;
			}
			//IS USED FOR A CONNeCTION
			println( "Now create a ConnReceiver input");
 			ConnReceiver cr = new ConnReceiver("inConn_source_"+getName(), conn, view);			
			cr.start();			
		} catch (Exception e) {
			System.out.println( "WARNING:" + e.getMessage()   );
			try {
				conn.closeConnection();
			} catch (Exception e1) {
				System.out.println( "ERROR " + e1  );
			}
			goon = false;
		}		
	}
	
	
	protected void forward_rowReady( String M  ) throws Exception {
	M = MsgUtil.putInEnvelope(M);
	IMessage m = new Message(receiver+"_rowReady("+getName()+",rowReady,"+M+",0)");
	//System.out.println("forward_rowReady: " + m.toString());
	conn.sendALine(m.toString());	
	}
 
	/*
	 * should always return true
	 */
	protected void checkAndStoreAnswer(String receivedMsg) {
//		if( receivedMsg == null ) return ; //throw new Exception("noMessage");
		try{
			IMessage mm = new Message(receivedMsg);
//			println("received " + mm );
		//A msgAnswer must simply stored in the sharedSpace
		String answer = chekForAnswer(receivedMsg,mm);
		if( answer != null ){
		if( mm.msgContent().startsWith("internalMsg_rawComm")){
			//Send a dispatch raw done on the same conn
			forward_rowReady("setRawMsg done");
// 			conn.sendRaw("ok".getBytes());
			rowLength = 0;
			Struct st = (Struct) Term.createTerm(mm.msgContent());
			rowMsgLength = Integer.parseInt( ""+st.getArg(0) );
			//System.out.println( "rowMsgLength = " + rowMsgLength );
			setRawMsg();
			return;
		}
 			//doprintln("received THE ANSWER:" + receivedMsg  );
			core.out( answer );
  		} 
  		else{
 			boolean withAnsw = RunTimeKb.getInputConnMsg( mm.msgId() );
  			receiveAndStore( mm,withAnsw );	//can raise and Exception noMessage
 		}
		}catch(Exception e){
			System.out.println( " |||| ERROR " + e.getMessage() );
//			rowMsg = true;
//			requestOn = true;
 		}
	}
	
	protected void doprintln( String msg){
 		String m = getName() + " | "  + msg;
		if( view != null ) view.addOutput( m );
		else System.out.println(m);		
	}

	protected void println( String msg){
  	 	if( debug )
			doprintln(msg);
	}		
}


